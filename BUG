tl;dr

close all file descriptors used internally before executing subprocesses.

file descriptors are inherited to subprocesses and are globally
readable and writeable.

----
bug: goodshut reports all pass even if there are fails.

bug occurs when subshells are changed to command groups.

before:
  ((((((
  runtests >&6; echo $? >&7
  ) 3>&1 | count >&3
  ) 4>&1 | count >&4
  ) 5>&1 | count >&5
  ) 3>&1 4>&1 5>&1 | summaryline >&6
  ) 7>&1 | stdintoexitstatus
  ) 6>&1

after:
  {{{{{{
  runtests >&6; echo $? >&7
  } 3>&1 | count >&3
  } 4>&1 | count >&4
  } 5>&1 | count >&5
  } 3>&1 4>&1 5>&1 | summaryline >&6
  } 7>&1 | stdintoexitstatus
  } 6>&1

goodshut is not modified. only shut is modified.

note: commands groups need whitespace around braces.

wrong: {{foo}}
correct: { { foo } }

using command groups without spaces causes syntax error.
the group of opening braces are treated as a command.
the closing braces are dangling because there are no opening braces.

but why does this mess up goodshut?
goodshut should report all fail. instead it reports all pass.

----
found the problem.

open file descriptors are inherited by child processes.

goodshut opens many file descriptors.
among others to pipe output and still capture exit status.

of interest is file descriptor 3.

fd 3 is used to pipe through the exit status. later fd 3 is
rerouted to fd 1. then it is read by stdintoexitstatus and
transformed to an actual exit status.

the subshell construct, which would be transformed to process groups,
also uses fd 3 to pipe some information.

the error in the syntax of the process groups is what triggered the bug.

since the opening braces had no space between them they were not
recognized as opening braces by bash. the closing braces however
are recognized as such.

the first closing brace closed the function declaration.
the second closing brace caused a syntax error.
everything after the first closing brace is now outside of the function
and is executed before the syntax error stopped the script.

between the first closing brace and the syntax error
there is a count function with output redirected to fd 3.
since the count function had no input the result of count was always 0.
that 0 was then redirected to fd 3.

fd 3 in the shut under test is inherited from fd 3 in goodshut.
in goodshut fd 3 was redirected to stdintoexitstatus.
that is why stdintoexitstatus always returns 0.
that is why goodshut always reports all pass even though all fail.
